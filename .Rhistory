# 3. Targets
target_80 <- 0.8 * est_richness
target_90 <- 0.9 * est_richness
# 4. Find where richness first reaches or exceeds targets
n_80 <- min(which(acc$richness >= target_80), na.rm = TRUE)
n_90 <- min(which(acc$richness >= target_90), na.rm = TRUE)
# If never reaches target, return NA
if (is.infinite(n_80)) n_80 <- NA
if (is.infinite(n_90)) n_90 <- NA
return(tibble(
Group = group_name,
Estimated_Richness = est_richness,
Samples_80pct = n_80,
Samples_90pct = n_90,
Max_Samples = length(acc$sites),
Max_Observed_Richness = max(acc$richness)
))
}
# Run for all groups
results_tbl <- imap_dfr(species_list, samples_to_target)
# View results
print(results_tbl)
print(n=40)
print(n=...)
View(results_tbl)
#Now we need to make this into wide format aka each row is a sample with all the species in columns
# Ensure SampleID and species columns are clean
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, sep = "_")) %>%
select(SampleID, Group, Species, Catch, year, Season)
#Checking that above worked properly
#If many groups only have 1 SampleID, it means the grouping or pivoting step is aggregating multiple samples.
fish.comp3 %>%
group_by(Group) %>%
summarise(n_samples = n_distinct(SampleID)) %>%
arrange(n_samples)
# Pivot to wide format: samples as rows, species as columns
fish.comp_wide<- fish.comp3 %>%
pivot_wider(
id_cols = c(SampleID, Group),         # keep each sample distinct
names_from = Species,
values_from = Catch,
values_fill = 0
)
fish.comp_wide %>% count(Group)  # how many samples per group?
species_list <- fish.comp_wide %>%
group_by(Group) %>%
group_split() %>%
setNames(unique(fish.comp_wide$Group))
View(species_list)
#Now we need to make this into wide format aka each row is a sample with all the species in columns
# Ensure SampleID and species columns are clean
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, sep = "_")) %>%
select(SampleID, Group, Species, Catch)
#Checking that above worked properly
#If many groups only have 1 SampleID, it means the grouping or pivoting step is aggregating multiple samples.
fish.comp3 %>%
group_by(Group) %>%
summarise(n_samples = n_distinct(SampleID)) %>%
arrange(n_samples)
# Pivot to wide format: samples as rows, species as columns
fish.comp_wide<- fish.comp3 %>%
pivot_wider(
id_cols = c(SampleID, Group),         # keep each sample distinct
names_from = Species,
values_from = Catch,
values_fill = 0
)
fish.comp_wide %>% count(Group)  # how many samples per group?
species_list <- fish.comp_wide %>%
group_by(Group) %>%
group_split() %>%
setNames(unique(fish.comp_wide$Group))
# Keep only groups with 2+ samples
species_list <- species_list[sapply(species_list, nrow) >= 2]
# Remove metadata columns
species_list <- lapply(species_list, function(df) {
df %>% select(-SampleID, -Group)
})
save(list=ls(),file= here::here("working/RData", "Workplan_Fish_code_02.RData"))
#Now we need to make this into wide format aka each row is a sample with all the species in columns
# Ensure SampleID and species columns are clean
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, Season sep = "_")) %>%
select(SampleID, Group, Species, Catch)
#Now we need to make this into wide format aka each row is a sample with all the species in columns
# Ensure SampleID and species columns are clean
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, Season sep = "_")) %>%
select(SampleID, Group, Species, Catch)
#Now we need to make this into wide format aka each row is a sample with all the species in columns
# Ensure SampleID and species columns are clean
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, Season, sep = "_")) %>%
select(SampleID, Group, Species, Catch)
View(fish.comp3)
#Checking that above worked properly
#If many groups only have 1 SampleID, it means the grouping or pivoting step is aggregating multiple samples.
fish.comp3 %>%
group_by(Group) %>%
summarise(n_samples = n_distinct(SampleID)) %>%
arrange(n_samples)
# Pivot to wide format: samples as rows, species as columns
fish.comp_wide<- fish.comp3 %>%
pivot_wider(
id_cols = c(SampleID, Group),         # keep each sample distinct
names_from = Species,
values_from = Catch,
values_fill = 0
)
fish.comp_wide %>% count(Group)  # how many samples per group?
species_list <- fish.comp_wide %>%
group_by(Group) %>%
group_split() %>%
setNames(unique(fish.comp_wide$Group))
# Keep only groups with 2+ samples
species_list <- species_list[sapply(species_list, nrow) >= 2]
# Remove metadata columns
species_list <- lapply(species_list, function(df) {
df %>% select(-SampleID, -Group)
})
save(list=ls(),file= here::here("working/RData", "Workplan_Fish_code_02.RData"))
```{r Plot Accumulation Curves by Location × Gear}
#Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
load(here::here("working","RData", "Workplan_Fish_code_02.RData"))
library(vegan)
# Optional: Set color palette
library(RColorBrewer)
cols <- brewer.pal(min(length(species_list), 8), "Set2")
# Prepare plot space
plot(NULL,
xlim = c(1, max(sapply(species_list, nrow))),
ylim = c(0, max(sapply(species_list, function(mat) max(specaccum(mat)$richness)))),
xlab = "Samples",
ylab = "Species Richness",
main = "Species Accumulation by Location × Gear")
# Plot each group's accumulation curve
for (i in seq_along(species_list)) {
acc <- specaccum(species_list[[i]], method = "random")
lines(acc$sites, acc$richness, col = cols[i %% length(cols) + 1], lwd = 2)
}
legend("right", legend = names(species_list), col = cols, lwd = 2, cex = 0.7)
# 1. Calculate specaccum results for each group
accum_data <- lapply(names(species_list), function(name) {
acc <- specaccum(species_list[[name]], method = "random")
data.frame(
Samples = acc$sites,
Richness = acc$richness,
Group = name
)
})
# 2. Combine all into one data frame
accum_df <- bind_rows(accum_data)
# 3. Plot with ggplot2
ploX<-ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5)
)
ggsave(paste("RARE_CURVE2_",".png",sep = ""),path = here::here("working/Figures"), ploX, width = 1000, height = 500, dpi = 150, units = "px")
# 3. Plot with ggplot2
ploX<-ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5)
)
ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5)
)
ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5),legend.text=element_text(size=0.5)
)
ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0),legend.text=element_text(size=0.5)
)
library(dplyr)
library(vegan)
library(purrr)
# Function to calculate samples needed to reach 80% and 90% of estimated richness
samples_to_target <- function(species_matrix, group_name) {
# 1. Estimate asymptotic richness
pool <- specpool(species_matrix)
est_richness <- pool$chao
# 2. Accumulation curve
acc <- specaccum(species_matrix, method = "random")
# 3. Targets
target_80 <- 0.8 * est_richness
target_90 <- 0.9 * est_richness
# 4. Find where richness first reaches or exceeds targets
n_80 <- min(which(acc$richness >= target_80), na.rm = TRUE)
n_90 <- min(which(acc$richness >= target_90), na.rm = TRUE)
# If never reaches target, return NA
if (is.infinite(n_80)) n_80 <- NA
if (is.infinite(n_90)) n_90 <- NA
return(tibble(
Group = group_name,
Estimated_Richness = est_richness,
Samples_80pct = n_80,
Samples_90pct = n_90,
Max_Samples = length(acc$sites),
Max_Observed_Richness = max(acc$richness)
))
}
# Run for all groups
results_tbl <- imap_dfr(species_list, samples_to_target)
# View results
print(results_tbl)
View(results_tbl)
View(species_list)
library(iNEXT)
library(dplyr)
library(purrr)
install.packages("iNEXT")
library(iNEXT)
library(iNEXT)
library(dplyr)
library(purrr)
# Step 1: Convert each tibble to summed species abundance (across all samples)
abund_list <- map(species_list, ~ colSums(as.data.frame(.x)))
# Step 2: Run iNEXT to estimate asymptotic richness
out <- iNEXT(abund_list, q = 0, datatype = "abundance")
install.packages("C:/Users/edavidson/Downloads/iNEXT_3.0.1.tar.gz", repos = NULL, type = "source")
library(iNEXT)
install.packages("C:/Users/edavidson/Downloads/iNEXT_3.0.1.zip", repos = NULL, type = "win.binary")
library(iNEXT)
library(iNEXT)
install.packages("iNEXT")
library(iNEXT)
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
load(here::here("working","RData", "Workplan_Fish_code_01.RData"))
library(tidyverse)
library(vegan)
library(iNEXT)
library(tidyr)
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch) %>%
select(SampleID, Species, Catch)
fish.comp4 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, sep = "_")) %>%
select(SampleID, Group, Species, Catch)
fish.comp5 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, Season, sep = "_")) %>%
select(SampleID, Group, Species, Catch)
#Checking that above worked properly
#If many groups only have 1 SampleID, it means the grouping or pivoting step is aggregating multiple samples.
fish.comp3 %>%
group_by(Group) %>%
summarise(n_samples = n_distinct(SampleID)) %>%
arrange(n_samples)
fish.comp3 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= Location) %>%
select(SampleID, Group, Species, Catch)
fish.comp4 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, sep = "_")) %>%
select(SampleID, Group, Species, Catch)
fish.comp5 <- fish.comp2 %>%
mutate(SampleID = SampleID_frp,
Species = fish5.CommonName,
Catch = TotalCatch,
Group= paste(Location, GearTypeAbbreviation, Season, sep = "_")) %>%
select(SampleID, Group, Species, Catch)
#Checking that above worked properly
#If many groups only have 1 SampleID, it means the grouping or pivoting step is aggregating multiple samples.
fish.comp3 %>%
group_by(Group) %>%
summarise(n_samples = n_distinct(SampleID)) %>%
arrange(n_samples)
# Pivot to wide format: samples as rows, species as columns
fish.comp_wide<- fish.comp3 %>%
pivot_wider(
id_cols = c(SampleID, Group),         # keep each sample distinct
names_from = Species,
values_from = Catch,
values_fill = 0
)
fish.comp_wide %>% count(Group)  # how many samples per group?
species_list <- fish.comp_wide %>%
group_by(Group) %>%
group_split() %>%
setNames(unique(fish.comp_wide$Group))
# Keep only groups with 2+ samples
species_list <- species_list[sapply(species_list, nrow) >= 2]
# Remove metadata columns
species_list <- lapply(species_list, function(df) {
df %>% select(-SampleID, -Group)
})
save(list=ls(),file= here::here("working/RData", "Workplan_Fish_code_02.RData"))
#Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.
load(here::here("working","RData", "Workplan_Fish_code_02.RData"))
library(vegan)
# Optional: Set color palette
library(RColorBrewer)
cols <- brewer.pal(min(length(species_list), 8), "Set2")
# Prepare plot space
plot(NULL,
xlim = c(1, max(sapply(species_list, nrow))),
ylim = c(0, max(sapply(species_list, function(mat) max(specaccum(mat)$richness)))),
xlab = "Samples",
ylab = "Species Richness",
main = "Species Accumulation by Location × Gear")
# Plot each group's accumulation curve
for (i in seq_along(species_list)) {
acc <- specaccum(species_list[[i]], method = "random")
lines(acc$sites, acc$richness, col = cols[i %% length(cols) + 1], lwd = 2)
}
legend("right", legend = names(species_list), col = cols, lwd = 2, cex = 0.7)
# 1. Calculate specaccum results for each group
accum_data <- lapply(names(species_list), function(name) {
acc <- specaccum(species_list[[name]], method = "random")
data.frame(
Samples = acc$sites,
Richness = acc$richness,
Group = name
)
})
# 2. Combine all into one data frame
accum_df <- bind_rows(accum_data)
ploX<-ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location × Gear",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
ploX
ploX<-ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
ploX<-ggplot(accum_df, aes(x = Samples, y = Richness, color = Group)) +
geom_line(size = 1.2) +
labs(
title = "Species Accumulation by Location",
x = "Samples",
y = "Species Richness",
color = NULL  # removes default legend title
) +
theme_minimal() +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5)
)
ploX
save(list=ls(),file= here::here("working/RData", "Workplan_Fish_code_03.RData"))
library(dplyr)
library(vegan)
library(purrr)
# Function to calculate samples needed to reach 80% and 90% of estimated richness
samples_to_target <- function(species_matrix, group_name) {
# 1. Estimate asymptotic richness
pool <- specpool(species_matrix)
est_richness <- pool$chao
# 2. Accumulation curve
acc <- specaccum(species_matrix, method = "random")
# 3. Targets
target_80 <- 0.8 * est_richness
target_90 <- 0.9 * est_richness
# 4. Find where richness first reaches or exceeds targets
n_80 <- min(which(acc$richness >= target_80), na.rm = TRUE)
n_90 <- min(which(acc$richness >= target_90), na.rm = TRUE)
# If never reaches target, return NA
if (is.infinite(n_80)) n_80 <- NA
if (is.infinite(n_90)) n_90 <- NA
return(tibble(
Group = group_name,
Estimated_Richness = est_richness,
Samples_80pct = n_80,
Samples_90pct = n_90,
Max_Samples = length(acc$sites),
Max_Observed_Richness = max(acc$richness)
))
}
# Run for all groups
results_tbl <- imap_dfr(species_list, samples_to_target)
# View results
print(results_tbl)
View(species_list)
View(results_tbl)
View(fish.comp)
install.packages("C:/Users/edavidson/Downloads/iNEXT_3.0.1.zip", repos = NULL, type = "win.binary")
