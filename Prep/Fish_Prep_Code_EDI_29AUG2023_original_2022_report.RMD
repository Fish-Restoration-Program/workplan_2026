---
title: "FISH_DATA_PREP_ALL_09JAN2024"
output: html_document
editor_options: 
  chunk_output_type: console
---
This is chunk is used to import raw data and perform initial manipulations
```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.


#########################################


library(readxl)
library(dplyr)

#Input files are Site Visits and Sample export from db- be sure to note the data date were exported from the db and export new files if any updates have been make to the db.
# Import files (export 05JUL2023)
sample1 <- read.csv(here::here("working","Sample_18JAN2024.csv"), quote = "")
dwr_sv <- read.csv(here::here("working","SiteVisit_05JUL2023.csv"), header=T, quote = "") # All site visits from the export page
str(dwr_sv)




#This is creating new columns that might be needed for EDI, fish haven't used this before but might need to. 
sample1$Flagged_Data = NA
#Might remove if it turns out these aren't being used

#Convert Visit.Date to date format
typeof(dwr_sv$Visit.Date)
dwr_sv$Visit.Date2 <- NA
dwr_sv$Visit.Date2 <- factor(dwr_sv$Visit.Date)
dwr_sv$Visit.Date2<-mdy(dwr_sv$Visit.Date2)
dwr_sv$Visit.Date2<-as.Date(dwr_sv$Visit.Date2, format = "%Y-%m-%d")

#Use to double check that nothing weird happened when converting the dates
dwr_sv[,c("Visit.Date","Visit.Date2")]

#Create month and year variables 
dwr_sv$year = year(dwr_sv$Visit.Date2)
dwr_sv$month = month(dwr_sv$Visit.Date2)

#Filter for desired year(s)
dwr_sv_2022=filter(dwr_sv, dwr_sv$year== 2022)

save(list=ls(),file= here::here("RData","fish_prep_code_01.RData"))

```

Merging site and sample files, checking gear types and assigning seasons
```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData", "fish_prep_code_01.RData"))

library(dplyr)
library(lubridate)
library(readxl)



#######################################################################
#Test the merge of sample with dwr_sv to ensure nothing we want is dropped
nrow(sample1) ## 9520 rows
nrow(dwr_sv_2022) ## 629 rows
test=merge(sample1, dwr_sv_2022, by='VisitNo');test
nrow(test) ## 1163 rows; This information isn't helpful by itself yet; could be a good merge or there could be bad merges masking each other
unique(test$year) #2022
test2=merge(sample1, dwr_sv_2022, by='VisitNo', all=T)
nrow(test2) ## 9520 rows;The takeaway from the fact that test 2 has more rows.
      ### 1)Because test2 is a different size than test, it suggests that there are some visitNo's found in either sample1 or dwr_sv_2022 that is not found in the other. Otherwise, test2 would be the same size as test
      #This is expected since dwr_sv_2022 only has samples from 2022 and sample1 hasn't been filtered down to the desired year.
unique(test2$year)

###How do we identify these issues once we know they exist?
##If we have identified that visitNo's are duplicated, can use the aggregate function to determine which are those visitNo's
summary.table.x=with(sample1, aggregate(list(number=VisitNo), list(VisitNo=VisitNo), length)) ##This function creates a summary table of how many times a SampleID appears in the data set (can go into further detail if needed)
summary.table.x[which(summary.table.x$number!=1),] ##Filters out which SampleID shows up more than once (remember that in actual dataframe, this can be a large table rather than just 4 rows)
###Repeat with the other data set
summary.table.y=with(dwr_sv_2022, aggregate(list(number=VisitNo), list(VisitNo=VisitNo), length)) 
summary.table.y[which(summary.table.y$number!=1),] #Shows that SampleID shows up 3 times in the dataframe

###How do we identify which SampleIDs are found in 1 dataset and not the other?
`%!in%` = Negate(`%in%`) ##Run this line of code to create our own function which is %!in$; this function tells us what objects are not found in common between 2 vectors
(sample1$VisitNo) ##A vector of  SampleIDs found in dataframe x.3
(dwr_sv_2022$VisitNo) ##A vector of  SampleIDs found in dataframe y.3


test1=sample1[which(sample1$VisitNo %!in% dwr_sv_2022$VisitNo),] ##This function tells me that SampleID 4 is found in sample1 but not found in dwr_sv_2022
test2=dwr_sv_2022[which(dwr_sv_2022$VisitNo %!in% sample1$VisitNo),] ###Switch order around to determine what SampleIDs are found in dwr_sv_2022 but not sample1
# zero 2022 samples are missing from sample1, okay to move on




############################################################

# Merge site and sample files (CHECK # rows in sitesample should be = or > # rows in sample1) **merge vs join
sitesample= merge(sample1, dwr_sv_2022, by="VisitNo") 


# Change locations as needed
sort(unique(sitesample$Location))
#sitesample$Location[sitesample$Location == "Stacys Island"] <- "WTIB"


#rename file
ss2<- sitesample


#create Datetime column, potentially used for time of day analysis. R doesn't like regular time formats.
ss2$DateTime <-NA


ss2$DateTime <- paste(ss2$Visit.Date2, ss2$StartTime, sep = " ")

unique(ss2$DateTime)
typeof(ss2$DateTime)

library(lubridate)

#ss2$DateTime <-as.POSIXct(ss2$DateTime, format="%Y-%m-%d %H:%M:%S")

typeof(ss2$StartTime)
unique(ss2$StartTime)
#remove inaccurate date from the start time column
#ss2$StartTime<- substr(as.character(ss2$StartTime), 12, 16)


#add season 
#changed starting with Tule Red 2019;


#1. Winter - Jan 1- Feb 29
#2. Spring - Mar 1 - May 31
#3. Summer - Jun 1 - Aug 31
#4. Fall  - Sep 1 - Dec 31

#Check what months we have
unique(ss2$month)

(ss2$Season<-ifelse((ss2$month<=2), "Winter",
                  ifelse((ss2$month>=3) & (ss2$month<=5), "Spring",
                         ifelse((ss2$month>=6) & (ss2$month<=8), "Summer",
                                ifelse((ss2$month>=9) & (ss2$month<=12), "Fall",
                                              ifelse((ss2$month>13), "fix me", 0 ))))))
#Check that none say "fix me" or 0 or NA
unique(ss2$Season)

#Check gear types
sort(unique(ss2$GearTypeAbbreviation))

fish_in_inverts=filter(ss2, ss2$GearTypeAbbreviation== "MAC"|
             ss2$GearTypeAbbreviation == "NT"|
             ss2$GearTypeAbbreviation == "ZOOP"|
              ss2$GearTypeAbbreviation == "EAV"|
               ss2$GearTypeAbbreviation == "FAV"|
               ss2$GearTypeAbbreviation == "SAV"|
               ss2$GearTypeAbbreviation == "PPG"|
               ss2$GearTypeAbbreviation == "PVC"|
               ss2$GearTypeAbbreviation == "SR"
             )

unique(fish_in_inverts$GearTypeAbbreviation)

#Wrong spot for this, double check that it is below
#write.csv(fish_in_inverts, file=here::here("Export.Files", paste('fish_in_invert_samples', Sys.Date(),'.csv', sep = '')))

unique(ss2$GearTypeAbbreviation)

#Filter just fish gear types used in 2022
#Change ss2 to a different variable name instead of override
ss_fish=filter(ss2, ss2$GearTypeAbbreviation== "BEASEI"|
             ss2$GearTypeAbbreviation == "LAMOPE"|
             ss2$GearTypeAbbreviation == "BIGLAM"|
             ss2$GearTypeAbbreviation == "OTTTRA"|
             ss2$GearTypeAbbreviation == "CAST")
             #ss2$GearTypeAbbreviation == "BOEFISH"|
             #ss2$GearTypeAbbreviation == "EFISH"|
             #ss2$GearTypeAbbreviation == "FYKE"|
             #ss2$GearTypeAbbreviation == "GILNET"|
            # ss2$GearTypeAbbreviation == "KODI")

#check that only fish gear types are left
unique(ss_fish$GearTypeAbbreviation)

#File now ready for fish prep!

save(list=ls(),file= here::here("RData","fish_prep_code_02.RData"))

```


```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData", "fish_prep_code_02.RData"))


################################################################################################### 
#for feesh
# Prepare to check that the sample type (geartypeabbreviation) for each sample in the database matches its sampleID

# Make a df to hold data with issues
test <- data.frame(matrix(NA, nrow = nrow(ss_fish), ncol = 2))

# Change column name
names(test)[1]<-"SampleID"
names(test)[2]<-"Geartype"

# Change to character type
test$SampleID <- as.character(test$SampleID)
test$Geartype <- as.character(test$Geartype)
ss_fish$SampleID_frp <- as.character(ss_fish$SampleID_frp)
ss_fish$GearTypeAbbreviation <- as.character(ss_fish$GearTypeAbbreviation)

library(stringr)


# Change the way this is done later. Doesn't actually check that Geartype matches SampleID. Doesn't explicitly check that SampleID FRP is all fish.But, earlier checks make sure that the only GearTypeAbbreviations are fish ones, and this will check if any sampleIDs don't match their geartype. 
#E.G. if somehow MAC12-.... said it's geartype was LAMPOPE, below would catch that. 
# Check that the sample type (geartypeabbreviation) for each sample in the database matches its sampleID
 for (i in 1:nrow(ss_fish)){
   if (str_detect(ss_fish$SampleID_frp[i],regex("LAMOPE", ignore_case =   TRUE)) & ss_fish$GearTypeAbbreviation[i] != "LAMOPE"){
    test[i,1]<-ss_fish$SampleID_frp[i]
    test[i,2]<-ss_fish$GearTypeAbbreviation[i]}
   if (str_detect(ss_fish$SampleID_frp[i],regex("OTTTRA", ignore_case =   TRUE)) & ss_fish$GearTypeAbbreviation[i] != "OTTTRA"){
    test[i,1]<-ss_fish$SampleID_frp[i]
    test[i,2]<-ss_fish$GearTypeAbbreviation[i]}
  if (str_detect(ss_fish$SampleID_frp[i],regex("BEASEI", ignore_case =   TRUE)) & ss_fish$GearTypeAbbreviation[i] != "BEASEI"){
    test[i,1]<-ss_fish$SampleID_frp[i]
    test[i,2]<-ss_fish$GearTypeAbbreviation[i]}
  if (str_detect(ss_fish$SampleID_frp[i],regex("BIGLAM", ignore_case =   TRUE)) & ss_fish$GearTypeAbbreviation[i] != "BIGLAM"){
    test[i,1]<-ss_fish$SampleID_frp[i]
    test[i,2]<-ss_fish$GearTypeAbbreviation[i]}
 print(i/nrow(ss_fish)) }

# Save a list of all sampleID's where the SampleID and geartypes dont match within the database!
gtype_ss_fish_issues <- data.frame(test$SampleID,test$Geartype)
gtype_ss_fish_issues <- distinct(gtype_ss_fish_issues) # Cut it down to one row per SampleID, we dont need all of them

# Check if there are real issues, correct, and proceed
# There's a mismatch for 15 BIGLAM samples during spring 2022, didn't add new gear type until fall 2022, this is ok for now - ED 22JUN2023

# Save the file, use it to make corrections in Database
write.csv(gtype_ss_fish_issues, file = here::here("Export.Files","Data.Checks", "gtype_ss_fish_issues.csv"))
####
##################################################################################################################

save(list=c("dwr_sv", "ss2","ss_fish", "sample1", "sitesample", "fish_in_inverts"), file=here::here("RData","fish_prep_code_03.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all
```

Ensure depths are in meters
```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_03.RData"))

#rename ss_fish to f1
f1<-ss_fish

## We have some problems below. Some are missing seine code, some missing deployment ED 07JUN2023 ###
##### CHECK BEFORE MOVING ON!! #######################################

#This has been corrected for EDI data and in the future, when needing older data, use EDI. 

#FOR YEARS PRIOR TO 2019 DepthOfWater IS IN FEET IN DATABASE OUTPUT



#depth correction for draft of mudsucker only for lampara samples (only ones where volume is affected)

#some samples got depth from handheld or secchi, these don't need adjustment
library(stringr)


####THERE is now a variable in the database for this so it'll need to be updated below
###UPDATE FOR ANY YEARS PRIOR TO 2019
f1$DepthOfWater2 <- NA
f1$DepthOfWater2 <- ifelse(f1$Boat == "Mudsucker" & f1$GearTypeAbbreviation == "LAMOPE", f1$DepthOfWater+0.3, f1$DepthOfWater)
f1$DepthMeters <- ifelse(f1$Boat == "Mudsucker" & f1$GearTypeAbbreviation == "BIGLAM", f1$DepthOfWater2+0.3, f1$DepthOfWater2)

#Changes number of significant figures in depth to 2  
f1$DepthMeters <- signif(f1$DepthMeters, 2)

#Use to double check that nothing weird happened when converting the depths
#Only LAMOPE and BIGLAM samples on the Mudsucker should be adjusted by 0.3 Meters
f1[,c("DepthOfWater","DepthOfWater2","DepthMeters","Boat","GearTypeAbbreviation")]

#In future, there will be a column for depth source so this bit won't be needed
#Grabs any samples with the words "depth from" in the comments
f1$Comments <- tolower(f1$Comments) # make all comments lower case so grepl finds them
depth_handheld = f1[grepl('depth from', f1$Comments),]
nrow(depth_handheld) # 3 for 2022. 
length(f1$GearTypeAbbreviation[which(f1$GearTypeAbbreviation=="LAMOPE")])

#Make a duplicate column of DepthOfWater2 to house calculated values
f1$DepthMeters2 = f1$DepthMeters

#Check that nothing weird happened with the new column
f1[,c("DepthMeters","DepthMeters2","Boat","GearTypeAbbreviation")]

depth_handheld[,c("DepthOfWater","DepthMeters","Boat","GearTypeAbbreviation")]

#For SampleIDs in Depth_handheld df, make the final depth the original depth, since handheld methods are true depth and need no adjustment
for (i in 1:nrow(f1)){
  for (j in 1:nrow(depth_handheld)){
    if (f1$SampleID_frp[i]==depth_handheld$SampleID_frp[j]){
      f1$DepthMeters2[i]=depth_handheld$DepthOfWater[j]
    }
  }
}


#check that it worked
test_depth_handheld = filter(f1, f1$DepthMeters2 != f1$DepthMeters) #the same samples as in depth_handheld should show up in this test. All 3 for 2022 did! -ED 05JUL2023
# It did! 
# a few samples missing depth, checked, they are code 3 or Otter Trawls, a couple are missing altogether so we'll apply the maximum depth later on-ED 08JUN2023
test = f1[c('SampleID_frp','GearTypeAbbreviation','Boat','DepthOfWater' ,'DepthMeters', 'DepthMeters2','SeineCode')]

test_depth = filter(f1, is.na(f1$DepthMeters)==T)
unique(f1$DepthMeters)
#Create new volume column, apply volume estimated column to new column, new volumes calculated later on. Avoids losing samples.
f1$volume <- f1$VolumeEstimated
f1$volume <- NA


save(list=c("dwr_sv", "ss2","ss_fish","f1", "sample1", "sitesample", "fish_in_inverts"), file=here::here("RData","fish_prep_code_04.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all
```


```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_04.RData"))

unique(f1$SeineCode)

test_seinecode = filter(f1, f1$SeineCode==" ") #correct in database then re-download sitevisit/sample
# All corrected for 2022, seine code field added to trawl entry in database in 2023

#check that all have NetNumber
unique(f1$NetNumber)
test_netnumber = filter(f1, is.na(f1$NetNumber)==T) #correct in database then re-download sitevisit/sample
#Otter trawls or missing net number on datasheet, multiple nets were used during this time so can't definitively say which net was used. 


# Save the file, use it to make corrections in Database
write.csv(test_netnumber, file = here::here("Export.Files","Data.Checks","missing_netnumber.csv")) # samples from 14NOV2022 and 15NOV2022 missing net number on datasheets
#Otter trawls missing net number, no net numbers have been assigned yet. ok to move on - ED 05JUL2023

#check that all have Veg %
unique(f1$CodEndPercent)

test_veg = filter(f1, f1$CodEndPercent == " ") #correct in database then re-download sitevisit/sample

# Save the file, use it to make corrections in Database
write.csv(test_veg, file = here::here("Export.Files","Data.Checks", "missing_veg.csv")) #these samples do not have cod end percent recorded on datasheet, bring to group with how to handle - ED 05JUL2023



########## RESTART HERE

#The following section does not work. Samples missing "paired" are still missing paired for now. 

#Grabs any samples with the word "paired" in the comments - NEEDS WORK!
missing_paired = f1[grepl('paired', f1$Comments),]

# #change for consistency
# missing_paired$Comments2 <- gsub("paired:", "paired ", missing_paired$Comments)
# missing_paired$Comments3 <- gsub("paired?", "paired ", missing_paired$Comments2)
# missing_paired$Comments4 <- gsub("paired.", "paired ", missing_paired$Comments3)
# missing_paired$Comments5 <- gsub("not paired.", "paired n", missing_paired$Comments4)
# missing_paired$Comments6 <- gsub("?", "", missing_paired$Comments5)
# 
# 
# 
# f1$Paired = NA
# 
# for (i in 1:nrow(missing_paired)){
#   if (grepl("paired y", missing_paired$Comments6[i])){
#     missing_paired$Paired[i]= "Y"
#   }
#   if (grepl("paired n", missing_paired$Comments6[i])){
#     missing_paired$Paired[i]= "N"
#   }
# 
# }
# 
# for (i in 1:nrow(f1)){
#   for (j in 1:nrow(missing_paired)){
#     if (f1$SampleID_frp[i]==missing_paired$SampleID_frp[j]){
#       f1$Paired[i]= missing_paired$Paired[j]
#     }
#   }
# }


#Removes leading and trailing spaces
f1$SeineCode <- trimws(f1$SeineCode, which = c("both"))
f1$GearTypeAbbreviation <- trimws(f1$GearTypeAbbreviation, which = c("both"))
f1$SeineDeploymentType <- trimws(f1$SeineDeploymentType, which = c("both"))




#exclude if seine code= 3 or 4 (did not sample)
#First check how many there are
Test<-f1[((f1$SeineCode == "4. DTS") | f1$SeineCode == "3. Complete twist; snag; or large tear") ,]
nrow(Test)# 19
unique(Test$SeineCode) # Should just have 3 and 4
Test2<-f1[!((f1$SeineCode == "4. DTS") | f1$SeineCode == "3. Complete twist; snag; or large tear") ,]
nrow(Test2)# 256
unique(Test2$SeineCode) #Should just have 1 and 2

nrow(unique(f1[c("SampleID_frp")])) - nrow(Test)-nrow(Test2) #Should be zero


f2<-f1[!((f1$SeineCode == "4. DTS") | f1$SeineCode == "3. Complete twist; snag; or large tear") ,]



f_check<- f2 %>% count(f2$GearTypeAbbreviation,f2$SeineDeploymentType) #Checked against sample inventory- matches ED 05JUL2023

#Add sample inventory to check against like invert code
#Use f_check as a reference CHECK that all sample types and deployment methods are included in volume calculations below and are correct! 

unique(f2$SeineDeploymentType)
test_deployment = filter(f2, f2$SeineDeploymentType=="") #Correct in database then re-download sitevisit/sample
# Corrected, only otter trawls left and don't need this- ED 08JUN2023


## DSE - confirm counts add up
nrow(unique(f2[c("GearTypeAbbreviation","SeineDeploymentType")])) - nrow(f_check)
# SHOULD BE ZERO
## it is - ED 05JUL2023


#Lists what gear types and deployment methods are present in the data
unique(f2$GearTypeAbbreviation)
unique(f2$SeineDeploymentType)



############################### Do fish calculations- finally!##############################




save(list=c("dwr_sv", "ss2","ss_fish", "sample1", "sitesample","f1", "f2", "fish_in_inverts","f_check"),file=here::here("RData","fish_prep_code_05.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```


Check against sample inventory
```{r}
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.


load(here::here("RData","fish_prep_code_05.RData"))

library(readxl)
#Make sure to copy latest version into data prep folder (working directory)
fish_sample_inventory<- read_excel(here::here("working","2022 FRP FISH Sample Inventory_05JUL2023.xlsx"))

###How do we identify which SampleIDs are found in 1 dataset and not the other?
`%!in%` = Negate(`%in%`) ##Run this line of code to create our own function which is %!in$; this function tells us what objects are not found in common between 2 vectors
(fish_sample_inventory$SampleID_frp) ##A vector of  SampleIDs found in dataframe x.3
(f2$SampleID_frp) ##A vector of  SampleIDs found in dataframe y.3

test_samp1 = fish_sample_inventory[which(fish_sample_inventory$SampleID_frp %!in% f2$SampleID_frp),] ##This function tells me what SampleIDs are found in fish_sample_inventory but not found in f2
test_samp2 = f2[which(f2$SampleID_frp %!in% fish_sample_inventory$SampleID_frp),] ###Switch order around to determine what SampleIDs are found in f2 but not fish_sample_inventory

test_samp11 = test_samp1[c('SampleID_frp','VisitNo', 'Seine Code')]
names(test_samp11)[which(colnames(test_samp11)=="SampleID_frp")]<-"Inv_SampleID_frp"

test_samp22 = test_samp2[c('SampleID_frp','VisitNo', 'SeineCode')]

test_sample_IDs = merge(test_samp11, test_samp22, by = "VisitNo", all=T) #all codes 3's or 4 so good! -ED 30JUn2023


save(list=c("dwr_sv", "ss2","ss_fish", "sample1", "sitesample","f1", "f2", "fish_in_inverts","f_check"),file=here::here("RData","fish_prep_code_06.RData"))

```


Beach seine outlier checks
```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_06.RData"))
#BEACH SEINE


#Pull only beachseines with crew. Note "Crew Members" was spelled differently in other years.
beachseine <- subset(f2, f2$GearTypeAbbreviation == "BEASEI") 


#Check that number of deployment types match number returned in new dataframes
table(beachseine['SeineDeploymentType'])

#Check for NA in Depth, Length, Width, and net number
test_d= filter(beachseine, is.na(beachseine$DepthMeters2)==T)
test_l= filter(beachseine, is.na(beachseine$LengthOfTrawl)==T)
test_w= filter(beachseine, is.na(beachseine$Width)==T)
test_netnumber= filter(beachseine, is.na(beachseine$NetNumber)==T)

###depth, length, width checks ######################################################################################

hist(beachseine$DepthMeters2) #Should not exceed 1.2
hist(beachseine$LengthOfTrawl) #Should not exceed 15, without explanation
hist(beachseine$Width) #Should not exceed 15

boxplot(beachseine$DepthMeters2) #Should not exceed 1.2
boxplot(beachseine$LengthOfTrawl) #Should not exceed 15, without explanation
boxplot(beachseine$Width) #Should not exceed 15

# Calculate quantiles for beach seine dimensions
quant_BSD = quantile(beachseine$DepthMeters2, na.rm=T) # beachseine_depth: 0%- 0.4, 25%- 0.625, 50%- 0.8, 75%- 0.9, 100%- 1
quant_BSW = quantile(beachseine$Width, na.rm=T) # beachseine_width: 0%- 8, 25%- 10.5, 50%- 13.2, 75%- 15, 100%- 15
quant_BSL = quantile(beachseine$LengthOfTrawl, na.rm=T) # beachseine_length: 0%- 8, 25%- 10.5, 50%- 13.2, 75%- 15, 100%- 15

# Store the quantile values for beach seine depths
Q1_bsd = quant_BSD[2] # Put 25% value here
Q3_bsd = quant_BSD[4] # Put 75% value here
IQR_bsd = Q3_bsd - Q1_bsd
min_bsd = Q1_bsd - 1.5*IQR_bsd
max_bsd = Q3_bsd + 1.5*IQR_bsd

# Set aside samples which are greater than the max or less than the min
check_bsd = filter(beachseine, beachseine$DepthMeters2 < min_bsd | beachseine$DepthMeters2 > max_bsd)

# Store the quantile values for beach seine widths
Q1_bsw = quant_BSW[2] # Put 25% value here
Q3_bsw = quant_BSW[4] # Put 75% value here
IQR_bsw = Q3_bsw - Q1_bsw
min_bsw = Q1_bsw - 1.5*IQR_bsw
max_bsw = Q3_bsw + 1.5*IQR_bsw

# Set aside samples which are greater than the max or less than the min
check_bsw = filter(beachseine, beachseine$Width < min_bsw | beachseine$Width > max_bsw)


# Store the quantile values for beach seine lengths
Q1_bsl = quant_BSL[2] # Put 25% value here
Q3_bsl = quant_BSL[4] # Put 75% value here
IQR_bsl = Q3_bsl - Q1_bsl
min_bsl = Q1_bsl - 1.5*IQR_bsl
max_bsl = Q3_bsl + 1.5*IQR_bsl

# Set aside samples which are greater than the max or less than the min
check_bsl = filter(beachseine, beachseine$LengthOfTrawl < min_bsl | beachseine$LengthOfTrawl > max_bsl)

# Merge the files
BeachSeine_check = rbind(check_bsw, check_bsl, check_bsd) #No outliers ED 18JAN2024

write.csv(BeachSeine_check, file = here::here("Export.Files","Data.Checks","BeachSeine_check.csv"))

# Correct outliers before continuing if needed


###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(beachseine$DepthMeters2) 
boxplot(beachseine$LengthOfTrawl) 
boxplot(beachseine$Width) 

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_BSD = filter(beachseine, beachseine$DepthMeters2 > min_bsd )
test_BSD = filter(test_BSD, test_BSD$DepthMeters2 < max_bsd)
test_BSW = filter(beachseine, beachseine$Width > min_bsw )
test_BSW = filter(test_BSW,test_BSW$Width < max_bsw)
test_BSL = filter(beachseine, beachseine$LengthOfTrawl > min_bsl )
test_BSL = filter(test_BSL,test_BSL$LengthOfTrawl < max_bsl)

boxplot(test_BSD$DepthMeters)
boxplot(test_BSW$Width) 
boxplot(test_BSL$LengthOfTrawl)
# END OF QC
################################################################################

# takes the mean and fills it in for samples missing a value
beachseine$LengthOfTrawl[is.na(beachseine$LengthOfTrawl)] <- mean(beachseine$LengthOfTrawl, na.rm = TRUE)
beachseine$DepthMeters2[is.na(beachseine$DepthMeters2)] <- mean(beachseine$DepthMeters2, na.rm = TRUE)
beachseine$Width[is.na(beachseine$Width)] <- mean(beachseine$Width, na.rm = TRUE)



# ##Volume Calcs
#  for (i in 1:nrow(beachseine)){
#    if (beachseine$SeineDeploymentType == "CrewMembers"){
#      beachseine$volume<-((0.5*beachseine$DepthMeters*beachseine$LengthOfTrawl*
#                             beachseine$Width))
#      }
#  #    if (beachseine$SeineDeploymentType == "Boat"){
#  #     beachseine$volume <-(((4/3)*pi*beachseine$DepthMeters*beachseine$Width*
#  #                             beachseine$LengthOfTrawl)/4)
#  #     }
#  #    
#  #       
#  }            




#subset beach seine deployed by crewmembers for volume calculation
beachseine_crew <- subset(beachseine, beachseine$SeineDeploymentType == "Crew Members")


#Calculation for beach seine volume
beachseine_crew$volume<-((0.5*beachseine_crew$DepthMeters2*beachseine_crew$LengthOfTrawl*beachseine_crew$Width))

#check that volumes calculated
table(beachseine_crew['volume'])

#randomly select 3 samples and calculate manually to check calculation is good
# (Length*Width*Depth) /2
library(dplyr)
test_volume=beachseine_crew[,c("LengthOfTrawl","Width","DepthMeters2","volume")]
test_beach=sample_n(test_volume,3)

#Manually checked, good to go - ED 10JUN2023


#Check that number of deployment types match number returned in new dataframes
table(beachseine['SeineDeploymentType'])#14, that's all for 2022



#beachseines with boat - not needed for 2022 ED 10JUN2023
beachseine_boat <- subset(beachseine, beachseine$SeineDeploymentType == "Boat") 
#CHECK Beach seine with crewmembers and a boat, quarter of an elipsoid calculation
beachseine_boat$volume <- ((4/3)*pi*beachseine_boat$DepthMeters2*beachseine_boat$Width*beachseine_boat$LengthOfTrawl)/4

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
sample_n(beachseine_boat,3)

#Check that number of deployment types match number returned in new df
table(beachseine['SeineDeploymentType'])


#################### Beach seine Drag and Drop Volume calculations #########################

#beach seine drag & drop 
beachseine_dragdrop <- subset(beachseine, beachseine$SeineDeploymentType == "Drag and Drop") 

#for the volume calculation
bsdd_centerlength <- sqrt(((beachseine_dragdrop$LengthOfTrawl)^2)-(0.25*(((beachseine_dragdrop$Width)-0.1)^2)))

beachseine_dragdrop$volume <- (((beachseine_dragdrop$DepthMeters2*bsdd_centerlength)/6)*((2*0.1)+beachseine_dragdrop$Width))

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
sample_n(beachseine_dragdrop,3)

#beach seines with Drag & Drop End
beachseine_dragdropend <- subset(beachseine, beachseine$SeineDeploymentType == "Drag & Drop End") 
beachseine_dragdropend$volume<-(((4/3)*pi*beachseine_dragdropend$LengthOfTrawl*beachseine_dragdropend$Width*beachseine_dragdropend$DepthMeters2)/4)

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
sample_n(beachseine_dragdropend,3)

#Check that number of deployment types match number returned in new df
table(beachseine['SeineDeploymentType'])

beachseine_alldragdrop <- rbind(beachseine_dragdrop, beachseine_dragdropend)

#to check that volumes calculated correctly, none are negative, none are empty, none are greater than 40 m^3
table(beachseine_alldragdrop['volume'])


#### MERGE ALL BEACH SEINES
#
beachseine_ddb<-full_join(beachseine_alldragdrop, beachseine_boat)
beachseine_all<-full_join(beachseine_crew, beachseine_ddb)

#Check that number of deployment types match number returned in new df
table(beachseine['SeineDeploymentType'])
table(beachseine_all['SeineDeploymentType'])


####################### OUTLIER DETECTION - VOLUME CHECKS ALL BEACH SEINES ############################

hist(beachseine_crew$volume) #maximum volume 135m^3, unless an explanation is provided
hist(beachseine_boat$volume) #Should not exceed 
hist(beachseine_dragdrop$volume) #Should not exceed 39.6
hist(beachseine_dragdropend$volume) #Should not exceed 282.6 without explanation
hist(beachseine_all$volume) #Should not exceed

boxplot(beachseine_crew$volume) #maximum volume 135m^3, unless an explanation is provided
boxplot(beachseine_boat$volume) #Should not exceed 
boxplot(beachseine_dragdrop$volume) #Should not exceed 
boxplot(beachseine_dragdropend$volume) #Should not exceed
boxplot(beachseine_all$volume) #Should not exceed

# Calculate quantiles for beach seine volumes
quant_bsc = quantile(beachseine_crew$volume, na.rm=T) # beachseine_crew: 0%- 2.4, 25%- 26.8, 50%- 41.8, 75%- 64, 100%- 123.8
quant_bsb = quantile(beachseine_boat$volume, na.rm=T) # beachseine_boat: 0%- 38.3, 25%- 57.6, 50%- 77, 75%- 95, 100%- 113.1
quant_bsdd = quantile(beachseine_dragdrop$volume, na.rm=T) # beachseine_dragdrop: 0%- 5.4, 25%- 7.93, 50%- 12.41, 75%- 19.48, 100%- 29.8
quant_bsdde = quantile(beachseine_dragdropend$volume, na.rm=T) # beachseine_dragdropend: 0%- 52.8, 25%- 88.7, 50%- 124.6, 75%- 125.7, 100%- 126.7
quant_bs = quantile(beachseine_all$volume, na.rm=T) # beachseine_all: 0%- 2.4, 25%- 24.5, 50%- 41.2, 75%- 63.6, 100%- 123.8

# Store the quantile values for beach seine crew
Q1_bsc = quant_bsc[2] # Put 25% value here
Q3_bsc = quant_bsc[4] # Put 75% value here
IQR_bsc = Q3_bsc - Q1_bsc
min_bsc = Q1_bsc - 1.5*IQR_bsc
max_bsc = Q3_bsc + 1.5*IQR_bsc

# Set aside samples which are greater than the max or less than the min
check_bsc = filter(beachseine_crew, beachseine_crew$DepthMeters2 < min_bsc | beachseine_crew$DepthMeters2 > max_bsc)

# Store the quantile values for beach seine boat
Q1_bsb = quant_bsb[2] # Put 25% value here
Q3_bsb = quant_bsb[4] # Put 75% value here
IQR_bsb = Q3_bsb - Q1_bsb
min_bsb = Q1_bsb - 1.5*IQR_bsb
max_bsb = Q3_bsb + 1.5*IQR_bsb

# Set aside samples which are greater than the max or less than the min
check_bsb = filter(beachseine_boat, beachseine_boat$volume < min_bsb | beachseine_boat$volume > max_bsb)


# Store the quantile values for beach seine drag drop
Q1_bsdd = quant_bsdd[2] # Put 25% value here
Q3_bsdd = quant_bsdd[4] # Put 75% value here
IQR_bsdd = Q3_bsdd - Q1_bsdd
min_bsdd = Q1_bsdd - 1.5*IQR_bsdd
max_bsdd = Q3_bsdd + 1.5*IQR_bsdd

# Set aside samples which are greater than the max or less than the min
check_bsdd = filter(beachseine_dragdrop, beachseine_dragdrop$volume < min_bsdd | beachseine_dragdrop$volume > max_bsdd)

# Store the quantile values for beach seine drag drop end
Q1_bsdde = quant_bsdde[2] # Put 25% value here
Q3_bsdde = quant_bsdde[4] # Put 75% value here
IQR_bsdde = Q3_bsdde - Q1_bsdde
min_bsdde = Q1_bsdde - 1.5*IQR_bsdde
max_bsdde = Q3_bsdde + 1.5*IQR_bsdde

# Set aside samples which are greater than the max or less than the min
check_bsdde = filter(beachseine_dragdropend, beachseine_dragdropend$volume < min_bsdde | beachseine_dragdropend$volume > max_bsdde)

# Store the quantile values for all beach seines
Q1_bs = quant_bs[2] # Put 25% value here
Q3_bs = quant_bs[4] # Put 75% value here
IQR_bs = Q3_bs - Q1_bs
min_bs = Q1_bs - 1.5*IQR_bs
max_bs = Q3_bs + 1.5*IQR_bs

# Set aside samples which are greater than the max or less than the min
check_bs = filter(beachseine_all, beachseine_all$volume < min_bs | beachseine_all$volume > max_bs)


# Merge the files
BeachSeine_volumecheck = rbind(check_bsc, check_bsb, check_bsdd, check_bsdde, check_bs)

write.csv(BeachSeine_volumecheck, file = here::here("Export.Files","Data.Checks","BeachSeine_volumecheck.csv"))

# Correct outliers
#Good to go - ED 05JUL2022

###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(beachseine$DepthMeters2) 
boxplot(beachseine$LengthOfTrawl) 
boxplot(beachseine$Width) 

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_BSD = filter(beachseine, beachseine$DepthMeters2 > min_bsd )
test_BSD = filter(test_BSD, test_BSD$DepthMeters2 < max_bsd)
test_BSW = filter(beachseine, beachseine$Width > min_bsw )
test_BSW = filter(test_BSW,test_BSW$Width < max_bsw)
test_BSL = filter(beachseine, beachseine$LengthOfTrawl > min_bsl )
test_BSL = filter(test_BSL,test_BSL$LengthOfTrawl < max_bsl)

boxplot(test_BSD$DepthMeters2)
boxplot(test_BSW$Width) 
boxplot(test_BSL$LengthOfTrawl)
# END OF QC
################################################################################

save(list=c("beachseine_all","dwr_sv", "ss2","ss_fish", "sample1", "sitesample","f1", "f2", "fish_in_inverts","f_check"), file=here::here("RData","fish_prep_code_07.RData")) #replace list=ls() with list=c("names of objects you want to keep") , list-ls() keeps all

```

BIG Lampara volume calculations and checks
```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_07.RData"))

#Pull out BIGLAM
biglam <- subset(f2, f2$GearTypeAbbreviation == "BIGLAM") #19 in sample inventory, one is a code 3, so 18 is the correct number of samples



#create a datafram with the constants from table in Seine Volume Calcs, from Big Lampara sheet, 3rd table
biglam_constants <- data.frame(TotalWidth = c(5.3,10,15.55,20,25,30,35,40), a = c(2.65,5,7.775,10,12.5,15,17.5,20), b = c(27.18,25.53,24.65,23.75,21.52,20.39,17.95,17.5), NEW_R = c(13.71918506,13.25462005,13.55,13.98026316,14.39034387,15.7124105, 17.50564067,20.17857143), Theta = c(2.947209,2.754791,2.529768,2.344546,2.089145,1.873078,1.596182,1.437659))

biglam_calcs<-biglam_constants

#check that all samples have depth
test_d= filter(biglam, is.na(biglam$DepthMeters2)==T)

#replace volume NA with avg volume for all samples
biglam$DepthMeters2[is.na(biglam$DepthMeters2)] <- mean(biglam$DepthMeters2, na.rm = TRUE)
biglam$DepthMeters2 <- signif(biglam$DepthMeters2, 2)


biglam$ave_vol=NA

for (i in 1:nrow(biglam)){
  biglam_calcs$h=biglam$DepthMeters2[i]
  biglam_calcs$vol=(biglam_calcs$h/(3*biglam_calcs$b))*((biglam_calcs$a*((3*(biglam_calcs$NEW_R^2))-(biglam_calcs$a^2)))+((3*(biglam_calcs$NEW_R^2))*(biglam_calcs$b-biglam_calcs$NEW_R)*biglam_calcs$Theta))
  biglam$volume[i]= mean(biglam_calcs$vol)
  biglam_calcs$h=NA
  biglam_calcs$vol=NA
}  

#check that all samples have volume
test_v= filter(biglam, is.na(biglam$volume)==T)

# Now check for outliers########################################
hist(biglam$volume)

boxplot(biglam$volume)

# Calculate quantiles for beach seine volumes
quant_biglam = quantile(biglam$volume, na.rm=T) # biglam: 0%- 222, 25%- 371, 50%- 494, 75%- 587, 100%- 815

# Store the quantile values for beach seine crew
Q1_biglam = quant_biglam[2] # Put 25% value here
Q3_biglam = quant_biglam[4] # Put 75% value here
IQR_biglam = Q3_biglam - Q1_biglam
min_biglam = Q1_biglam - 1.5*IQR_biglam
max_biglam = Q3_biglam + 1.5*IQR_biglam

# Set aside samples which are greater than the max or less than the min
check_biglam = filter(biglam, biglam$volume < min_biglam | biglam$volume > max_biglam)


write.csv(check_biglam, file = here::here("Export.Files","Data.Checks", "BIGLAM_volumecheck.csv"))

# Correct outliers


###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(biglam$volume)

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_biglam = filter(biglam, biglam$volume > min_biglam )
test_biglam = filter(test_biglam, test_biglam$volume < max_biglam)


boxplot(test_biglam$volume)

# END OF QC


save(list=c("beachseine_all", "biglam","dwr_sv", "ss2","ss_fish", "sample1", "sitesample","f1", "f2", "fish_in_inverts","f_check"),file=here::here("RData","fish_prep_code_08.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all


```


Lampara volume calculations and outlier checks
```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_08.RData"))

#Numbers in the following calculations come from the Seine Volume Calculations excel file found in Working folder. Created by Dave Contreras


#Lamparas- 	separate LAMOPE
lamope <- subset(f2, f2$GearTypeAbbreviation == "LAMOPE" ) #199, checked against f_check and it's the right number
lamope$volume<- NA

#Width and length aren't needed for lampara calculations, unless weird circumstances...drag & drop. If you have deployments besides boat and crewmembers and boat, then check. 
test_d= filter(lamope, is.na(lamope$DepthMeters2)==T)
#test_l= filter(lamope, is.na(lamope$LengthOfTrawl)==T) #Not needed 
#test_w= filter(lamope, is.na(lamope$Width)==T)
test_deploy= filter(lamope, is.na(lamope$SeineDeploymentType)==T)

#Change missing SeineDeploymentType to Boat, vast majority are boat samples, but check individual samples to confirm
lamope$SeineDeploymentType[is.na(lamope$SeineDeploymentType)] <- "Boat"


#replace depth NA with maximum value
# this can make the cpue falsely low but better than inflating CPUE
lamope$DepthMeters2[is.na(lamope$DepthMeters2)] <- 3.6
# DSE - is this really a safe assumption?
##ECD - it has to do with the volume calculation. it's the maximum depth the net can fish

#lamope$SeineDeploymentType[lamope$SeineDeploymentType == "Crew Members"] <- "Boat"# made the decision to change all to Boat, based on datasheet errors but double check later!!
unique(lamope$SeineDeploymentType)




#Pull only boat
lamope_boat <- subset(lamope, lamope$SeineDeploymentType == "Boat")

#separate lamope deeper than 12'
lamope_boatdeep<-subset(lamope_boat, lamope_boat$DepthMeters2 >= 3.6)
lamope_boatshallow<-subset(lamope_boat,lamope_boat$DepthMeters2 < 3.6)
  
lamope_boatdeep$volume<-332.7


##Lampara boat equations use depth in feet, conversion built into equations
lamope_boatshallow$volume <-(-0.7915*(lamope_boatshallow$DepthMeters2*3.2808)^2)+
  (37.921*(lamope_boatshallow$DepthMeters2*3.2808)) - 8.3261

#randomly select 3 samples and calculate manually to check calculation is good
test_volume=lamope_boatshallow[,c("DepthMeters2","volume")]
test_lamope_shallow= dplyr::sample_n(test_volume,3)

### Same as LAMBE crew in previous years
lamope_crew <- subset(lamope, lamope$SeineDeploymentType == "Crew Members")

## Maximum depth that the net samples is 3.65 meters, replace any value over 3.65 with 3.65 for lampara crew calculations
#lamope_crew$DepthMeters <- ifelse (lamope_crew$DepthMeters > 3.6, lamope_crew$DepthMeters <- 3.6, lamope_crew$DepthMeters <- lamope_crew$DepthMeters)
lamope_crewdeep<-subset(lamope_crew, lamope_crew$DepthMeters2 >= 3.6)
lamope_crewshallow<-subset(lamope_crew,lamope_crew$DepthMeters2 < 3.6)
lamope_crewdeep$DepthMeters2 <- 3.6
lamope_crew <- rbind(lamope_crewdeep, lamope_crewshallow)

test_w= filter(lamope_crew, is.na(lamope_crew$Width)==T)

#lamope_crew = filter(lamope_crew, lamope_crew$SeineCode != "3. Complete twist; snag; or large tear" )

h <- lamope_crew$DepthMeters2
a <- lamope_crew$Width/2
b <- lamope_crew$LengthOfTrawl
R <- ((((lamope_crew$Width/2)^2)+((lamope_crew$LengthOfTrawl)^2))/(2*lamope_crew$LengthOfTrawl))
Theta <- (0.5*pi)+atan(((b)-(R))/(a)) # Id suggest using "pi" here 

lamope_crew$volume<- (h/(3*(b)))*(((a)*((3*R^2)-((a)^2)))+(3*(R^2)*((b)-R))*Theta)


#randomly select 3 samples and calculate manually to check calculation is good
test_volume=lamope_boatshallow[,c("DepthMeters2","volume")]
test_lamope_crew= dplyr::sample_n(test_volume,3)

# Lampara deployed by crewmember and boat volume calculation
lamope_crewboat <- subset(lamope, lamope$SeineDeploymentType == "Crew Members and Boat")
lamope_crewboat$volume<-(-0.7915*((lamope_crewboat$DepthMeters2*3.2808)^2)) +((37.921* lamope_crewboat$DepthMeters2*3.2808)) - 8.3261

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
test_creboat=sample_n(lamope_crewboat,3)

# Lampara drag and drop at the end of a channel volume calculation
lamope_dragdropend <- subset(lamope, lamope$SeineDeploymentType == "Drag & Drop End")
lamope_dragdropend$volume <- ((4/3)*pi*lamope_dragdropend$LengthOfTrawl * lamope_dragdropend$Width * lamope_dragdropend$DepthMeters2)/4

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
sample_n(lamope_dragdropend,3)

#Lampara drag and drop deployed in the middle of a channel
lamope_dragdropmid <- subset(lamope, lamope$SeineDeploymentType == "Drag & Drop Middle")
lamope_dragdropmid$volume <- (lamope_dragdropmid$LengthOfTrawl * lamope_dragdropmid$Width * (lamope_dragdropmid$DepthMeters2*3.2808) * 0.5)

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
sample_n(lamope_dragdropmid,3)

#MERGE ALL LAMOPE
lamope_allboat<-rbind(lamope_boatdeep,lamope_boatshallow)
lamope_alldrag<-rbind(lamope_dragdropend,lamope_dragdropmid)
lamope_a<-rbind(lamope_allboat, lamope_alldrag)
lamope_all<-rbind(lamope_crew,lamope_allboat,lamope_crewboat, lamope_alldrag)


#Check that number of deployment types match number returned in new df
table(lamope['SeineDeploymentType'])
table(lamope_all['SeineDeploymentType'])
#Should match!!





####################### OUTLIER DETECTION - VOLUME CHECKS ALL Lampara ############################

 
hist(lamope_all$volume)

boxplot(lamope_all$volume)

# Calculate quantiles for beach seine volumes
quant_lamope_all = quantile(lamope_all$volume, na.rm=T) # lamope_all: 0%- 51.7, 25%- 178.6, 50%- 241.2, 75%- 322.8, 100%- 445.5

# Store the quantile values for beach seine crew
Q1_lamope_all = quant_lamope_all[2] # Put 25% value here
Q3_lamope_all = quant_lamope_all[4] # Put 75% value here
IQR_lamope_all = Q3_lamope_all - Q1_lamope_all
min_lamope_all = Q1_lamope_all - 1.5*IQR_lamope_all
max_lamope_all = Q3_lamope_all + 1.5*IQR_lamope_all

# Set aside samples which are greater than the max or less than the min
check_lamope_all = filter(lamope_all, lamope_all$volume < min_lamope_all | lamope_all$volume > max_lamope_all)


write.csv(check_lamope_all, file = here::here("Export.Files","Data.Checks", "Lampara_volumecheck.csv"))

# Correct outliers


###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(lamope_all$volume)

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_lamope = filter(lamope_all, lamope_all$volume > min_lamope_all )
test_lamope = filter(test_lamope, test_lamope$volume < max_lamope_all)


boxplot(test_lamope$volume)

# END OF QC


save(list=c("beachseine_all","lamope_all", "biglam" , "f1", "f2", "sitesample", "stations", "fish_in_inverts"),file=here::here("RData","fish_prep_code_07.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```


Otter Trawl volume calculations and outlier checks, merge gear types back together following outlier checks
```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_07.RData"))

unique(f2$GearTypeAbbreviation)

other_gear=filter(f2, f2$GearTypeAbbreviation == "CAST"|
             f2$GearTypeAbbreviation == "BOEFISH"|
             f2$GearTypeAbbreviation == "EFISH"|
             f2$GearTypeAbbreviation == "FYKE"|
             f2$GearTypeAbbreviation == "GILNET"|
             f2$GearTypeAbbreviation == "KODI")


#OTTERTRAWL
ottertrawl <- subset(f2, f2$GearTypeAbbreviation == "OTTTRA") 

#calculate rotations
ottertrawl$rotations <- (ottertrawl$NetMeterEnd)-(ottertrawl$NetMeterStart)


ottertrawl$rotation.final=rep(c('a'), nrow(ottertrawl))

 
#looking for number of rows with positive numbers
length(ottertrawl[ottertrawl$rotations>0,]$rotations)

#looking for rotations that are greater than zero and not NA, then replacing it 
ottertrawl[ottertrawl$rotations>0 & !is.na(ottertrawl$rotations),]$rotation.final=ottertrawl[ottertrawl$rotations>0 & !is.na(ottertrawl$rotations),]$rotations
 

unique(ottertrawl[ottertrawl$rotations<0 & !is.na(ottertrawl$rotations),]$rotations)
length(ottertrawl[ottertrawl$rotations<0 & !is.na(ottertrawl$rotations),]$rotations)
ottertrawl[ottertrawl$rotations<0 & !is.na(ottertrawl$rotations),]$rotation.final=ottertrawl[ottertrawl$rotations<0 & !is.na(ottertrawl$rotations),]$NetMeterEnd+(999999-ottertrawl[ottertrawl$rotations<0 & !is.na(ottertrawl$rotations),]$NetMeterStart)

 
#puts a zero if there's any NAs
ottertrawl[is.na(ottertrawl$rotations),]$rotation.final=0

str(ottertrawl$rotation.final)
ottertrawl$rotation.final <- as.numeric(ottertrawl$rotation.final)

#check that all samples have duration
test_dur= filter(ottertrawl, is.na(ottertrawl$Duration)==T)

ottertrawl$rpm <- ottertrawl$rotation.final/ottertrawl$Duration


ottertrawl$volume <- ((ottertrawl$rotation.final)*0.02687*2.75)

#randomly select 3 samples and calculate manually to check calculation is good
library(dplyr)
tes_otter=sample_n(ottertrawl,3)

####################### OUTLIER DETECTION - VOLUME CHECKS ALL Lampara ############################


hist(ottertrawl$volume)

boxplot(ottertrawl$volume)

# Calculate quantiles for otter trawl volumes
quant_ottra = quantile(ottertrawl$volume, na.rm=T) # OtterTrawl: 0%- 103898, 25%- 114503, 50%- 126677, 75%- 140876, 100%- 150913

# Store the quantile values for beach seine crew
Q1_ottra = quant_ottra[2] # Put 25% value here
Q3_ottra = quant_ottra[4] # Put 75% value here
IQR_ottra = Q3_ottra - Q1_ottra
min_ottra = Q1_ottra - 1.5*IQR_ottra
max_ottra = Q3_ottra + 1.5*IQR_ottra

# Set aside samples which are greater than the max or less than the min
check_ottra = filter(ottertrawl, ottertrawl$volume < min_ottra | ottertrawl$volume > max_ottra)


write.csv(check_ottra, file = here::here("Export.Files","Data.Checks", "Otter_volumecheck.csv"))

# Correct outliers


###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(ottertrawl$volume)

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_ottra = filter(ottertrawl, ottertrawl$volume > min_ottra )
test_ottra = filter(test_ottra, test_ottra$volume < max_ottra)


boxplot(test_ottra$volume)

####################### OUTLIER DETECTION - RPM CHECKS ALL Lampara ############################


hist(ottertrawl$rpm)
plot(ottertrawl$rotation.final, ottertrawl$Duration)

boxplot(ottertrawl$rpm)

# Calculate quantiles for otter trawl rpm
quant_ottrarpm = quantile(ottertrawl$rpm, na.rm=T) # OtterTrawl: 0%- 103898, 25%- 114503, 50%- 126677, 75%- 140876, 100%- 150913

# Store the quantile values for beach seine crew
Q1_ottrarpm = quant_ottrarpm[2] # Put 25% value here
Q3_ottrarpm = quant_ottrarpm[4] # Put 75% value here
IQR_ottrarpm = Q3_ottrarpm - Q1_ottrarpm
min_ottrarpm = Q1_ottrarpm - 1.5*IQR_ottrarpm
max_ottrarpm = Q3_ottrarpm + 1.5*IQR_ottrarpm

# Set aside samples which are greater than the max or less than the min
check_ottrarpm = filter(ottertrawl, ottertrawl$rpm < min_ottrarpm | ottertrawl$rpm > max_ottrarpm)


write.csv(check_ottra, file = here::here("Export.Files","Data.Checks", "Otter_rpmcheck.csv")) #Checked against datasheets, matches up. Must have just been a little slow/a little fast on these two. -ED 05JUL2023

# Correct outliers



###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(ottertrawl$rpm)

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_ottrarpm = filter(ottertrawl, ottertrawl$rpm > min_ottrarpm )
test_ottrarpm = filter(test_ottrarpm, test_ottrarpm$rpm < max_ottrarpm)


boxplot(test_ottra$volume)


# END OF QC

##############  MERGE ALL SEINES AND LAMPARAS AND OTTER TRAWL;
library(dplyr)


lamope_beasei<-rbind(beachseine_all, lamope_all)

fish <- bind_rows(lamope_beasei, ottertrawl)
fish1<-bind_rows(fish, biglam)
#fish1<-bind_rows(fish, other_gear)

#Checks for differences between f2 and fish1 to make sure they merged correctly
bind_check <- anti_join(fish1, f2, by=c('SampleID_frp', 'VisitNo', 'Comments.y')) #Should be zero



#Check that the datasets merged properly by picking a random sample ID and comparing in f2 and fish1
# library(arsenal)
# 
# summary(comparedf(f2, fish1, by="SampleID_frp"))


#Check that all gear types in f2 are present in fish1
unique(f2$GearTypeAbbreviation)

#Check that all gear types are present
unique(fish1$GearTypeAbbreviation)


f_check2<- fish1 %>% count(fish1$GearTypeAbbreviation,fish1$SeineDeploymentType)

#Check that number of samples for each method matches number returned in new df
table(f2['GearTypeAbbreviation'])
table(fish1['GearTypeAbbreviation'])
#should be equal. They are - ED 05JUL2023




#check sample sizes by location and station
fish_sample<- fish1 %>% count(Location)

save(list=c("beachseine_all","lamope_all", "ottertrawl", "biglam", "f1", "f2", "sitesample", "stations", "fish1","fish_in_inverts","f_check2"),file=here::here("RData","fish_prep_code_08.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```

Add fish catch data
```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_08.RData"))


################################################# add catch ##########################################
#Import db export file for fish catch
catch1 <- read.csv("Fish_03AUG2023.csv", quote = "")

#change column TagSerial to character instead of numeric
class(catch1$TagSerial)
catch1$TagSerial <- as.character(catch1$TagSerial)

#
### Combine catch and fish sample data
#
library(readxl)
#Add species 
org <- read.csv("OrganismCode_ZooCodes_Merged_09JAN2024.csv")
names(org)[which(colnames(org)=="..OrganismID")]<-"OrganismID"
#Fix capitalization
#org$OrganismId<-org$OrganismID

#Change Organism code for BLUKIL and RAIKIL to 1381 so that they are combined in KILSPP
#catch1$OrganismId[catch1$OrganismId == 54] <- 1381 #BLUKIL to KILSPP
#catch1$OrganismId[catch1$OrganismId == 422] <- 1381 #RAIKIL to KILSPP

#merge fish data with site and sample data
fish2<-merge(fish1, catch1, by.x = "SampleID_key", all.x= T)
fish_in_inverts2 <-merge(fish_in_inverts, catch1, by.x = "SampleID_key", all.x= T)

#Add species info to fish data
fish3<-merge(fish2, org, by.x = "OrganismId", by.y = "OrganismID", all.x= T)
fish_in_inverts3<-merge(fish_in_inverts2, org, by.x = "OrganismId", by.y = "OrganismID", all.x= T)

#helps me remember that all fish lengths are in this one
fishlengths <- fish3
fish_verts_lengths <- fish_in_inverts3

library(dplyr)

#Limit to 1 record for each sample- species combination. (Drops multiple length measurements.)
#one row with counts for each species, not lengths for all
#use catch1 if wanting all length meausrements
catch2 <-catch1 %>% distinct(SampleID_key, OrganismId, .keep_all=TRUE)






#excel file with all fish species and lengths
write.csv(fishlengths, file=here::here("Export.Files", paste('Fish_catch_all', "_",Sys.Date(),".csv", sep = '')))
write.csv(fish_verts_lengths, file=here::here("Export.Files", paste('Fish__inverts_all_lengths', "_",Sys.Date(),".csv", sep = '')))


######COUNT CHECK################
# Christy helped explain, there is maybe a better way
#makes a column titled f2 with a value of one
f2$f2=1
#makes a column titled fish1 with a value of one
fish1$fish1=1
#merge together
f2_fish1<-merge(x=f2,y=fish1,by="SampleID_frp",all=TRUE)
#Add f2 and fish1, should equal 2 if present in both dataframes
f2_fish1$check<-f2_fish1$f2 + f2_fish1$fish1
write.csv(f2_fish1, file = here::here("Export.Files","Data.Checks", "Sample_Check.csv"))
#If any "1"s are present in the "check" column, that means the sample is missing from either f2 or fish1

# end of check ------------------------------------------------------------


############################## Count Check ##########################################################
# To check that the number of measured fish and plus count add up to the total catch per sample/species combo


#Make fish3 a dataframe
fish3 = data.frame(fish3)

#christy what does this do?
#fish3[fish3 == 0] <- NA

#filter out only chordata (fish)
Chord_only = filter(fish3, fish3$Phylum == "Chordata")
fish_only = filter(Chord_only, Chord_only$Class != "Amphibia")

Chord_only_verts = filter(fish_in_inverts3, fish_in_inverts3$Phylum == "Chordata")
fish_only_verts = filter(Chord_only_verts, Chord_only_verts$Class != "Amphibia")

library(plyr)
library(dplyr)


# Make the dataframe and calculate count, effort, for each taxa group in a SampleID
#counts_check = summarize(group_by(fish_only, SampleID_frp, OrganismCode),length_count = length(is.na(FishLength)==F))
counts_check = ddply(fish_only, c("SampleID_frp", "OrganismCode"), 
                  summarise,
                           length_count = length(is.na(FishLength)==F)
                           )

counts_check_verts = ddply(fish_only_verts, c("SampleID_frp", "OrganismCode"), 
                  summarise,
                           length_count = length(is.na(FishLength)==F)
                           )


# add the calculated count to your other data set
fish4 = merge(fish3, counts_check, by=c("SampleID_frp","OrganismCode"), all.x=T)

fish_in_inverts4 = merge(fish_in_inverts3, counts_check_verts, by=c("SampleID_frp","OrganismCode"), all.x=T)

# Make it so we have one row per sampleid-species combination
fish_test=distinct(fish4,fish4$SampleID_frp, fish4$CommonName, .keep_all = T)

fish_in_verts_test=distinct(fish_in_inverts4,fish_in_inverts4$SampleID_frp, fish_in_inverts4$CommonName, .keep_all = T)

# make a column to hold the check
fish_test$count_check = NA

fish_in_verts_test$count_check = NA


# Calculate the difference
fish_test$count_check = (fish_test$TotalCatch - fish_test$PlusCount-fish_test$length_count)

fish_in_verts_test$count_check = (fish_in_verts_test$TotalCatch - fish_in_verts_test$PlusCount - fish_in_verts_test$length_count)

# Check your results
test_fish_counts = filter(fish_test, fish_test$count != 0)

test_fish_in_verts_counts = filter(fish_in_verts_test, fish_in_verts_test$count != 0)


#Equals zero when all counts add up
#Plus count only species (invertebrates or carp (other fish) when they jump out) might have a value of -1 due to length_count being NA (which apparently still counts as one)
#Good to go, only plus count fish left that add up in database and match datasheets - ED 06JUl2023


#export and correct any fish counts that are wrong
write.csv(test_fish_counts, file = here::here("Export.Files","Data.Checks", paste('fish_count_check', "_",Sys.Date(),".csv", sep = '')))

write.csv(test_fish_in_verts_counts, file = here::here("Export.Files","Data.Checks", paste('fish_in_verts_count_check', "_",Sys.Date(),".csv", sep = '')))

#Correct any fish counts that are off in database and re-export


save(list=ls(),file= here::here("RData","fish_prep_code_09.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```


```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_09.RData"))

##############################################################################################

fish_test$volume <- as.numeric(fish_test$volume)


#calculate CPUE=(total catch/volume)*10000 by species
fish_test$CPUEbySpp<-((fish_test$TotalCatch/fish_test$volume))*10000

library(dplyr)
library(plyr)

##changes value to a zero if Legend_Fish is na (avoids inverts or nonfish CPUE being counted in total CPUE)
fish_test$CPUEbySpp2<-if_else(is.na(fish_test$Legend_Fish== T)|fish_test$Legend_Fish== "No Catch"|fish_test$Legend_Fish== "", true=0, false=fish_test$CPUEbySpp, missing=0)


#TotalCPUE<-aggregate(fish_test$CPUEbySpp2, by=list(SampleID_key=fish_$SampleID_key), FUN=sum)

#TotalCPUE = summarize(group_by(fish_test, SampleID_frp), tCPUE = sum(CPUEbySpp2))
#sum TotalCatch by Sample, total cpue per sample

TotalCPUE = ddply(fish_test, c("SampleID_frp"), 
                  summarise,
                           tCPUE = sum(CPUEbySpp2)
                           )

nrow(unique(fish_test[c("SampleID_frp")])) - nrow(TotalCPUE) # should be zero


#test= fish3[which(fish3$SampleID_frp=="BEASEI01-HORS-10NOV2021"),]
test= fish3[which(fish3$GearTypeAbbreviation=="OTTTRA"),]
fish4=fish_test

# has one row per species-sampleID combo
fish5<-merge(fish4, TotalCPUE, by = "SampleID_frp", all.x=T)

# do the sampleid #s match up where they should
# Should be zero
nrow(unique(fish_test[c("SampleID_frp", "CommonName")])) - nrow(fish5)

fish5$PercentComp<- fish5$CPUEbySpp2/fish5$tCPUE
#fish5$x2<-fish5$x

#removes No catch
#fish5$tCPUE<- ifelse(fish5$CommonName== "No Catch", fish5$tCPUE ==0, fish5$tCPUE<-fish5$tCPUE)

# do not remove no catch --------------------------------------------------


    
                     
                     
#Fish5 has multiple records per sample; 1 record (row) for each individual fish in a sample 
                     
### tCPUE is the total CPUE by SampleID     

#make it so we have one row per species per sample ID
                     
fish6 = distinct(fish5, fish5$SampleID_frp,fish5$CommonName,.keep_all = T) 


# makes one row per sampleID, tCPUE is the total CPUE for the sample --------

# Same as adult.samp in figure code
TotalCPUE4 <-fish6%>% distinct(SampleID_frp, .keep_all=TRUE) 


#TotalCPUE4 has 1 record (row) per sample with totoal CPUE. CPUE is the sum of all individual species CPUE. 
#(Note there is some remnant taxonomic info here that should be ignored. Eventually can drop those variables to clean up the file.)
# 
# library(reshape2)
# 
# # Make df wide format and group by Legend column
# # This puts in zeros for any taxa which were not found in a SampleID
# ComMat.1 = dcast(fish6, formula = SampleID_frp~CommonName, value.var="CPUEbySpp2", fun.aggregate = sum, fill = 0)
# 
# 
# 
# # Make a long format version of ComMat.1- This merges better
# DWR.2x = melt(ComMat.1, id.vars = "SampleID_frp", variable.name = "CommonName", value.name = "CPUEbySpp2")
# 
# 
# 
# # Add the CPUE and Legend from DWR.2x to DWR.1
# # This adds rows for groups which had CPUE = 0
# fish.comp = merge(fish6, DWR.2x,by=c("SampleID_frp","CommonName","CPUEbySpp2"),all=T)
# 
# 
# # remove rows if sampleID is na ---------------------------------------------------------------
# fish.comp= filter(fish.comp, is.na(SampleID_frp) == F)
# 
# 
# # Copy in factors for merged data with empty cells
# for (i in 1:nrow(fish.comp)){
#   for(j in 1:nrow(fish.comp)){
#     if(fish.comp$SampleID_frp[i]==fish.comp$SampleID_frp[j]){
#       print(i)
#       if(is.na(fish.comp$Location[i])==F){
#         fish.comp$Location[j] = fish.comp$Location[i] # Location
#       }
#       if(is.na(fish.comp$Visit.Date[i])==F){
#         fish.comp$Visit.Date[j] = fish.comp$Visit.Date[i] # Visit.Date
#       }
#       if(is.na(fish.comp$Region2[i])==F){
#         fish.comp$Region2[j] = fish.comp$Region2[i] # Region2
#       }
#       if(is.na(fish.comp$year[i])==F){
#         fish.comp$year[j] = fish.comp$year[i] # year
#       }
#       if(is.na(fish.comp$Season[i])==F){
#         fish.comp$Season[j] = fish.comp$Season[i] # season
#       }
#       if(is.na(fish.comp$month[i])==F){
#         fish.comp$month[j] = fish.comp$month[i] # month
#       }
#       if(is.na(fish.comp$sitetype[i])==F){
#         fish.comp$sitetype[j] = fish.comp$sitetype[i] #sitetype
#       }
#       if(is.na(fish.comp$GearTypeAbbreviation[i])==F){
#         fish.comp$GearTypeAbbreviation[j] = fish.comp$GearTypeAbbreviation[i] #sitetype
#       }
#       if(is.na(fish.comp$Native[i])==F){
#         fish.comp$Native[j] = fish.comp$Native[i] #native v introduced
#       }
#       if(is.na(fish.comp$Phylum[i])==F){
#         fish.comp$Phylum[j] = fish.comp$Phylum[i] #Phylum
#       }
#     }
#   }
# }
# 
# 


#These are the input files for Fish_figs;

#write.csv(fish.comp, "fish.comp.csv")
write.csv(fish6, file=here::here("Export.Files", paste('fish.comp',"_", Sys.Date(),'.csv', sep = '')))

#need to eliminate inverts before this file-  replace inverts with no catch and change CPUE to zero
#write.csv(TotalCPUE4, "TotalCPUE4.csv")
write.csv(TotalCPUE4, file=here::here("Export.Files", paste('TotalCPUE4',"_", Sys.Date(),'.csv', sep = '')))

save(list=ls(),file= here::here("RData","fish_prep_code_10.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```

For EDI
```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_10.RData"))


fish7 <- fish6
TotalCPUE5 <-TotalCPUE4

#Used to Limit to a date range
fish7<-fish7 %>% filter(Visit.Date >= as.Date("2022-01-01", format = "%Y-%m-%d"))
fish7<- fish7 %>% filter(Visit.Date <= as.Date("2022-12-31", format = "%Y-%m-%d"))

TotalCPUE5<-TotalCPUE5 %>% filter(Visit.Date >= as.Date("2022-01-01", format = "%Y-%m-%d"))
TotalCPUE5<- TotalCPUE5 %>% filter(Visit.Date <= as.Date("2022-12-31", format = "%Y-%m-%d"))

fish7 <- fish7[,c("SampleID_key","CommonName", "TotalCatch", "FishLength", "FishCatchNotes")]


  
TotalCPUE5 <- TotalCPUE5[,c("SampleID_key","VisitNo", "SampleID_frp", "StartTime", "EndTime", "DateTime", "DepthMeters2", "NetMeterStart", "NetMeterEnd", "TowDirection", "SeineCode2","SeineDeploymentType", "LengthOfTrawl", "Width", "GearTypeAbbreviation", "volume")]

# Change column names
names(TotalCPUE5)[which(colnames(TotalCPUE5)=="SampleID_frp")]<-"SampleID"
names(TotalCPUE5)[which(colnames(TotalCPUE5)=="DepthMeters2")]<-"DepthOfWater"
names(TotalCPUE5)[which(colnames(TotalCPUE5)=="SeineCode2")]<-"SeineCode"


#write.csv(fish.comp, "fish.comp.csv")
write.csv(fish7, file=here::here("Export.Files", paste('fish.comp.EDI',"_", Sys.Date(),'.csv', sep = '')))


#write.csv(TotalCPUE4, "TotalCPUE4.csv")
write.csv(TotalCPUE4, file=here::here("Export.Files", paste('TotalCPUE5.EDI',"_", Sys.Date(),'.csv', sep = '')))

save(list=ls(),file= here::here("RData","fish_prep_code_11.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```


```{r}
# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_11.RData"))

####################### OUTLIER DETECTION - CPUE ############################

hist(fish5$CPUEbySpp2)
boxplot(fish5$CPUEbySpp2)
boxplot(TotalCPUE4$CPUEbySpp2)

# Calculate quantiles for beach seine volumes
quant_fish5 = quantile(fish5$CPUEbySpp2, na.rm=T) # fish5: 0%- 0, 25%- 508, 50%- 2156, 75%- 10989, 100%- 341111
quant_TotalCPUE4 = quantile(TotalCPUE4$CPUEbySpp2, na.rm=T) # TotalCPUE4: 0%- 0, 25%- 2.30e-01, 50%- 7.77e+01, 75%- 3.45e+02, 100%- 3.4e+05

# Store the quantile values for beach seine crew
Q1_fish5 = quant_fish5[2] # Put 25% value here
Q3_fish5 = quant_fish5[4] # Put 75% value here
IQR_fish5 = Q3_fish5 - Q1_fish5
min_fish5 = Q1_fish5 - 1.5*IQR_fish5
max_fish5 = Q3_fish5 + 1.5*IQR_fish5

# Set aside samples which are greater than the max or less than the min
check_fish5 = filter(fish5, fish5$CPUEbySpp2 < min_fish5 | fish5$CPUEbySpp2 > max_fish5)


write.csv(check_fish5, "Fish5_CPUE_check.csv")


# Store the quantile values for beach seine crew
Q1_TotalCPUE4 = quant_TotalCPUE4[2] # Put 25% value here
Q3_TotalCPUE4 = quant_TotalCPUE4[4] # Put 75% value here
IQR_TotalCPUE4 = Q3_TotalCPUE4 - Q1_TotalCPUE4
min_TotalCPUE4 = Q1_TotalCPUE4 - 1.5*IQR_TotalCPUE4
max_TotalCPUE4 = Q3_TotalCPUE4 + 1.5*IQR_TotalCPUE4

# Set aside samples which are greater than the max or less than the min
check_TotalCPUE4 = filter(TotalCPUE4, TotalCPUE4$CPUEbySpp2 < min_TotalCPUE4 | TotalCPUE4$CPUEbySpp2 > max_TotalCPUE4)


write.csv(check_TotalCPUE4, "TotalCPUE4_CPUE_check.csv")
# Correct outliers


###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(fish5$CPUEbySpp2)
boxplot(TotalCPUE4$CPUEbySpp2)

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_fish5 = filter(fish5, fish5$CPUEbySpp2 > min_fish5 )
test_fish5 = filter(test_fish5, test_fish5$CPUEbySpp2 < max_fish5)

test_TotalCPUE4 = filter(TotalCPUE4, TotalCPUE4$CPUEbySpp2 > min_TotalCPUE4 )
test_TotalCPUE4 = filter(test_TotalCPUE4, test_TotalCPUE4$CPUEbySpp2 < max_TotalCPUE4)

boxplot(test_fish5$CPUEbySpp2)
boxplot(test_TotalCPUE4$CPUEbySpp2)

# END OF QC
################################################################################

save(list=ls(),file= here::here("RData","fish_prep_code_12.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```


```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_12.RData"))
####FROM HERE ON NEEDS WORK


################## SPECIES LENGTH CHECKS ##########################
#Get a list of all species in the dataframe
unique(fish5$CommonName)

fish_only = filter(fishlengths, fishlengths$Phylum == "Chordata", fishlengths$Class!= "Amphibia")

fish_in_verts_only = filter(fish_verts_lengths, fish_verts_lengths$Phylum == "Chordata", fish_verts_lengths$Class!= "Amphibia")

fish_in_mac_only = filter(fish_in_verts_only, fish_in_verts_only$GearTypeAbbreviation == "MAC")

#If you want to exclude invertebrates and no catches - need to finish. For outlier purposes not necessary 
#fish_only <- [fish5$CommonName != "palaemon", ] 

library(ggplot2)
library(viridis)

#Plots multiple small histograms of all species with lengths
#Look for strange values on histograms. For example, a lengtht hat is outside the normal range for a species.
#look for lengths showing up for species that are not measured
ggplot(data=fish_only, aes(x=FishLength)) +
  geom_histogram(bins = 15, color = "black", fill = "gray") +
  facet_wrap(~CommonName, scales = "free")+
  ggtitle("Fish Lengths") +
  theme_grey()
ggsave("AllFish Hist.jpeg", width = 20, height = 15, plot = last_plot())

project= "DATA_PREP"

Y1 = ggplot(data=fish_only, aes(x=FishLength, fill=Location))
jpeg(file = paste(project,"_",'ALL_ADULT_FISH_HIST_', Sys.Date(),'.jpg', sep = ''),quality=100, width=10,height=6,units='in', res=300) 
Y1+geom_histogram(bins = 15) +
  facet_wrap(~Legend_Fish, scales = "free")+
  ggtitle("Fish Lengths All Locations") +
  scale_x_continuous(labels = scales::number_format(accuracy = 1))+  scale_color_viridis()
dev.off()


###### Fish caught in invert sampling lengths check ####################

ggplot(data=fish_in_verts_only, aes(x=FishLength)) +
  geom_histogram(bins = 15, color = "black", fill = "gray") +
  facet_wrap(~CommonName, scales = "free")+
  ggtitle("Fish_in_verts_Lengths") +
  theme_grey()
ggsave("All_Fish_in_invert_Hist.jpeg", width = 20, height = 15, plot = last_plot())

project= "DATA_PREP"

Y1 = ggplot(data=fish_in_verts_only, aes(x=FishLength, fill=Location))
jpeg(file = paste(project,"_",'Fish_in_verts_Lengths All Locations_', Sys.Date(),'.jpg', sep = ''),quality=100, width=10,height=6,units='in', res=300) 
Y1+geom_histogram(bins = 15) +
  facet_wrap(~Legend_Fish, scales = "free")+
  ggtitle("Fish_in_verts_Lengths All Locations") +
  scale_x_continuous(labels = scales::number_format(accuracy = 1))+  scale_color_viridis()
dev.off()

######### fish caught in MAC samples lengths check ################

ggplot(data=fish_in_mac_only, aes(x=FishLength)) +
  geom_histogram(bins = 15, color = "black", fill = "gray") +
  facet_wrap(~CommonName, scales = "free")+
  ggtitle("Fish_in_MAC_Lengths") +
  theme_grey()
ggsave("All_Fish_in_MAC_Hist.jpeg", width = 20, height = 15, plot = last_plot())

project= "DATA_PREP"

Y1 = ggplot(data=fish_in_mac_only, aes(x=FishLength, fill=Location))
jpeg(file = paste(project,"_",'Fish_in_MAC_Lengths All Locations_', Sys.Date(),'.jpg', sep = ''),quality=100, width=10,height=6,units='in', res=300) 
Y1+geom_histogram(bins = 15) +
  facet_wrap(~Legend_Fish, scales = "free")+
  ggtitle("Fish_in_MAC_Lengths All Locations") +
  scale_x_continuous(labels = scales::number_format(accuracy = 1))+  scale_color_viridis()
dev.off()


####################### OUTLIER DETECTION - Fish Lengths ############################


hist(fish5$FishLength)

boxplot(fish5$FishLength)

# Calculate quantiles for beach seine volumes
quant_fishLength = quantile(fish5$FishLength, na.rm=T) # Fish Lengths: 0%- 0, 25%- 30, 50%- 46, 75%- 64, 100%- 635

# Store the quantile values for beach seine crew
Q1_fishLength = quant_fishLength[2] # Put 25% value here
Q3_fishLength = quant_fishLength[4] # Put 75% value here
IQR_fishLength = Q3_fishLength - Q1_fishLength
min_fishLength = Q1_fishLength - 1.5*IQR_fishLength
max_fishLength = Q3_fishLength + 1.5*IQR_fishLength

# Set aside samples which are greater than the max or less than the min
check_fishLength = filter(fish5, fish5$FishLength < min_fishLength | fish5$FishLength > max_fishLength)


write.csv(check_fishLength, "FishLength_check.csv")

# Correct outliers


###
##
#
# CHECK THOSE SAMPLES, ONLY PROCEED IF YOU DO NOT CONSIDER THEM OUTLIERS OR IF YOU JUST CORRECTED THEM !
#
##
###

# these wont be different unless you changed the data and got back to this step
boxplot(fish5$FishLength)

# This is what the data look like with calculated outliers removed (not necessarily the ones you kept/removed)
test_fishLength = filter(fish5, fish5$FishLength > min_fishLength )
test_fishLength = filter(test_fishLength, test_fishLength$FishLength < max_fishLength)


boxplot(test_fishLength$FishLength)

# END OF QC
################################################################################

#export these files for invert ES
write.csv(fish_in_mac_only, file=here::here("Export.Files", paste('fish_in_MAC',"_", Sys.Date(),'.csv', sep = '')))
write.csv(fish_in_verts_only, file=here::here("Export.Files", paste('fish_in_INVERTS',"_", Sys.Date(),'.csv', sep = '')))


####################################################################
# QC - END OF ADDING FLAG COMMENTS #################################


# Make a column for the data
fish4$Flagged_Data = NA
TotalCPUE4$Flagged_Data = NA

# Go through complete Flags dataframe and add comments to primary dataframe
for(i in 1:nrow(Flags)){
  # Find SampleIDs that match first row in Flags df
  # Paste in the item and its comment, it will add this to the existing list
  fish4$Flagged_Data[which(Flags$SampleID[i]==fish4$SampleID)]=paste0(fish4$Flagged_Data[which(Flags$SampleID[i]==fish4$SampleID)],"; ",Flags$Data_Type[i],", ","Flag ",Flags$Flag[i])
  TotalCPUE4$Flagged_Data[which(Flags$SampleID[i]==TotalCPUE4$SampleID)]=paste0(TotalCPUE4$Flagged_Data[which(Flags$SampleID[i]==TotalCPUE4$SampleID)],"; ",Flags$Data_Type[i],", ","Flag ",Flags$Flag[i])
}

# Now clean up how each Flag started- remove the NA
fish4$Flagged_Data= gsub("NA;","",fish4$Flagged_Data)
TotalCPUE4$Flagged_Data= gsub("NA;","",TotalCPUE4$Flagged_Data)


# Now add the site visit flags
for(i in 1:nrow(Flags)){
  # Find SampleIDs that match first row in Flags df
  # Paste in the item and its comment, it will add this to the existing list
  fish4$Flagged_Data[which(Flags$VisitNo[i]==fish4$VisitNo)]=paste0(fish4$Flagged_Data[which(Flags$VisitNo[i]==fish4$VisitNo)],"; ",Flags$Data_Type[i],", ","Flag ",Flags$Flag[i])
  TotalCPUE4$Flagged_Data[which(Flags$VisitNo[i]==TotalCPUE4$VisitNo)]=paste0(TotalCPUE4$Flagged_Data[which(Flags$VisitNo[i]==TotalCPUE4$VisitNo)],"; ",Flags$Data_Type[i],", ","Flag ",Flags$Flag[i])
}



fish4$Flagged_Data=str_replace(fish4$Flagged_Data, "NA; NA, Flag ", "")

TotalCPUE4$Flagged_Data=str_replace(TotalCPUE4$Flagged_Data, "NA; NA, Flag ", "")

#fish4=fish4%>% replace_with_na(replace = list(Flagged_Data=""))
# Check it worked
check_fish4 = filter(fish4,is.na(Flagged_Data)==F)
check_TotalCPUE4 = filter(TotalCPUE4,is.na(Flagged_Data)==F)


# QC - END OF ADDING FLAG COMMENTS #################################
####################################################################

# QC - ADDING FLAG COMMENTS ########################################

# Make a column for the data
###
##
# Note: starting a new column for flagged data is only necessary if site visits did not have it already
##
###
# DWR$Flagged_Data = NA
# Add in the flags from site visits
sv_flags = filter(dwr_sv,is.na(dwr_sv$Flagged_Data)==F)
# Make a dataframe to hold lists of flags
Flags <- data.frame(SampleID = character(nrow(sv_flags)), Data_Type = character(nrow(sv_flags)), Flag = numeric(nrow(sv_flags)))
# Copy over existing flagged data from site visits
Flags$Flag = sv_flags$Flagged_Data
Flags$VisitNo = sv_flags$VisitNo
# Make SampleID NA
Flags$SampleID = NA
Flags$Data_Type = NA
# # Make first row
# Flags$SampleID[nrow(Flags)]="ExampleID"
# Flags$Data_Type[nrow(Flags)]="PC"
# Flags$Flag[nrow(Flags)]=9999999
# Flags$VisitNo[nrow(Flags)]=9999999
# END OF FLAG COMMENTS QC ...for now ###############################

save(list=ls(),file= here::here("RData","fish_prep_code_13.RData")) #replace list=ls() with names of objects you want to keep, currently keeps all

```

CREATE FISHLENGTHS_MAC FILE. THIS CANNOT BE DONE UNTIL ALL LAB ENTRY AND QC IS DONE!!
```{r}

# Clear environment
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

load(here::here("RData","fish_prep_code_12.RData"))

#Load FRP Mac Data
site_visits_edi<-read.csv(here::here("C:/Users/edavidson/OneDrive - California Department of Fish and Wildlife/Documents/R/2022 Annual Reports/Figure Code", "SiteVisit_2022_LocWQchecked_DMC230629.csv")) # FROM DANNY

lengths_verts <-read.csv("Invertebrate_29AUG2023.csv") # FROM DATABASE
lengths_verts <- lengths_verts[,c("SampleID_key","OrganismId","EntryOrder","InvertebrateLength")]#Select desired columns, sampleID_key is a unique identifier for each measured individual
names(lengths_verts)[which(colnames(lengths_verts)=="InvertebrateLength")]<-"FishLength"

org <- read.csv("OrganismCode_ZooCodes_Merged_09JAN2024.csv")
names(org)[which(colnames(org)=="..OrganismID")]<-"OrganismId"

site_visits_edi <- site_visits_edi[,c("VisitNo","newLocation")]


sitesample<-sitesample %>% filter(Visit.Date >= as.Date("2022-01-01"))
sitesample<-sitesample %>% filter(Visit.Date <= as.Date("2022-12-31"))
sitesample <- sitesample[,c("VisitNo","SampleID_key", "GearTypeAbbreviation", "Location")]

catch1 <- catch1[,c("SampleID_key","FishLength","OrganismId","EntryOrder")]
all_catch <-rbind(catch1,lengths_verts)


sitesample_visit = merge(site_visits_edi, sitesample, by="VisitNo", all.x = T)
sitesample_visit_mac = subset(sitesample_visit, sitesample_visit$GearTypeAbbreviation == "MAC")

all_vert_lengths_sv = left_join(sitesample_visit_mac, all_catch, by = "SampleID_key", all.x=T)

fishlengths_MAC = left_join(all_vert_lengths_sv, org, by="OrganismId", all.x=T)

# Save for use in figure code, for histograms
write.csv(fishlengths_MAC, file=here::here("Export.Files", paste('Fishlengths_MAC', "_",Sys.Date(),".csv", sep = ''))


save(list=ls(),file= here::here("RData","fish_prep_code_14.RData"))
```

